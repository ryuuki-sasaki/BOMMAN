//=============================================================================
//  入力
//　作成日：2015/8/28
//　更新日：2015/8/28
//	制作者：佐々木隆貴
//=============================================================================
#include "Input.h"

const float STICK_DEAD = 0.3f; //無視する値(0〜1.0)
const float TRIGGER_DEAD = 0.1f;

//=============================================================================
//コンストラクタ
//=============================================================================
Input::Input(void)
{
	initalize();
}

//=============================================================================
//デストラクタ
//=============================================================================
Input::~Input(void)
{
}

//=============================================================================
//初期化
//=============================================================================
void Input::initalize()
{
	for(int i = 0; i < 256; i++)
	{
		key[i] = keyWas[i] = FALSE;
	}
}

//=============================================================================
//キーを押したとき(KEYDOWNメッセージを受け取ったとき)
//引数：キーの情報
//戻値：なし
//=============================================================================
void Input::keyDown(WPARAM wp)
{
	//前フレームが押されてなかったらkeywasもtrueに
	if(key[wp] == FALSE)
	{
		keyWas[wp] = TRUE;
	}
	//押されたキー（wp番目）をtrueに
	key[wp] = TRUE;
}

//=============================================================================
//キーを離したとき(KEYUPメッセージを受け取ったとき)
//引数：キーの情報
//戻値：なし
//=============================================================================
void Input::keyUp(WPARAM wp)
{
	//離したキー（wp番目）をfalseに
	key[wp] = FALSE;
}

//=============================================================================
//引数のキーが押されてるか
//引数：キーの情報
//戻値：引数番目のキーが押されているか
//=============================================================================
BOOL Input::isKeyPush(int id)
{
	//引数番目のキーの状態を返す
	return key[id];
}

//=============================================================================
//キーが押されたとき
//引数：キーの情報
//戻値：引数番目のキーが押されたか
//=============================================================================
BOOL Input::wasKeyPush(int id)
{
	if(keyWas[id] == TRUE && key[id] == TRUE)
	{
		keyWas[id] = FALSE;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//=============================================================================
//コントローラが接続されているかチェックする
//引数：なし
//戻値：なし
//=============================================================================
void Input::checkControllers()
{
	DWORD result;
	for( DWORD i = 0; i <MAX_CON; i++)
	{
		result = XInputGetState(i, &controllerState[i]);
		if(result == ERROR_SUCCESS)
		{
			connected[i] = true;
		}
		else
		{
			connected[i] = false;
		}
	}
}

//=============================================================================
//コントローラの状態を取得する
//引数：なし
//戻値：なし
//=============================================================================
void Input::readControllers()
{
	for(DWORD i = 0; i < MAX_CON; i++)
	{
		XInputGetState(i, &controllerState[i]);
		for(DWORD j = 0; j < BUTTON_SIZE; j++)
		{
			//現在押されていない場合は次押されたときにTRUEを返せるようにfalseを入れておく
			if(!(controllerState[i].Gamepad.wButtons & bt[j]))
			{
				wasPushFlg[i][j] = FALSE;
			}
		}
	}
}

//=============================================================================
//コントローラのボタンが押されているか
//引数：接続されたコントローラーの番号、ボタン情報
//戻値：引数番目のコントローラーのボタンが押されているか
//=============================================================================
BOOL Input::isGamePadPush(int num, DWORD button)
{
	//接続されていなければfalseを返す
	if(!connected[num - 1])
	{
		return FALSE;
	}
	return controllerState[num - 1].Gamepad.wButtons & button;
}

//=============================================================================
//コントローラのボタンが押されたか
//引数：接続されたコントローラーの番号、ボタン情報
//戻値：引数番目のコントローラーのボタンが押されたか
//=============================================================================
BOOL Input::wasGamePadPush(int num, DWORD button)
{	
	//接続されていなければfalseを返す
	if(!connected[num - 1])
	{
		return FALSE;
	}
	int i;
	//引数と配列に対応するボタン番号を探す
	for(i = 0; i < BUTTON_SIZE; i++)
	{
		if(button == bt[i])
			break;
	}
	if(i == BUTTON_SIZE)  //範囲外エラー
	{
		return FALSE;
	}
	//そのボタンが押されていて且つ”押された”フラグが立ってない
	if(controllerState[num -1].Gamepad.wButtons & button && !wasPushFlg[num -1][i]) 
	{
		wasPushFlg[num - 1][i] = TRUE;
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}

//=============================================================================
//左スティックX軸検出
//引数：接続されたコントローラーの番号
//戻値：スティックの傾き
//=============================================================================
float Input::getLeftStickX(int num)
{
	//接続されていなければ0を返す
	if(!connected[num - 1])
	{
		return 0;
	}
	//-32768~32767
	float x = (float)controllerState[num - 1].Gamepad.sThumbLX / 32767.0f;

	//遊び無視
	if(x > STICK_DEAD || x < -STICK_DEAD)
	{
		return x;
	}
	else
	{
		return 0;
	}
}

//=============================================================================
//左スティックY軸検出
//引数：接続されたコントローラーの番号
//戻値：スティックの傾き
//=============================================================================
float Input::getLeftStickY(int num)
{
	//接続されていなければ0を返す
	if(!connected[num - 1])
	{
		return 0;
	}
	//-32768~32767
	float y = (float)controllerState[num - 1].Gamepad.sThumbLY / 32767.0f;

	//遊び無視
	if(y > STICK_DEAD || y < -STICK_DEAD)
	{
		return y;
	}
	else
	{
		return 0;
	}
}

//=============================================================================
//右スティックX軸検出
//引数：接続されたコントローラーの番号
//戻値：スティックの傾き
//=============================================================================
float Input::getRightStickX(int num)
{
	//接続されていなければ0を返す
	if(!connected[num - 1])
	{
		return 0;
	}
	//-32768~32767
	float x = (float)controllerState[num - 1].Gamepad.sThumbRX / 32767.0f;

	//遊び無視
	if(x > STICK_DEAD || x < -STICK_DEAD)
	{
		return x;
	}
	else
	{
		return 0;
	}
}

//=============================================================================
//右スティックY軸検出
//引数：接続されたコントローラーの番号
//戻値：スティックの傾き
//=============================================================================
float Input::getRightStickY(int num)
{
	//接続されていなければ0を返す
	if(!connected[num - 1])
	{
		return 0;
	}
	//-32768~32767
	float y = (float)controllerState[num - 1].Gamepad.sThumbRY / 32767.0f;

	//遊び無視
	if(y > STICK_DEAD || y < -STICK_DEAD)
	{
		return y;
	}
	else
	{
		return 0;
	}
}

//=============================================================================
//左トリガー検出
//引数：接続されたコントローラーの番号
//戻値：トリガーの押され具合
//=============================================================================
float Input::getLeftTrigger(int num)
{
	//接続されていなければ0を返す
	if(!connected[num - 1])
	{
		return 0;
	}
	//0〜255
	float z = (float)controllerState[num - 1].Gamepad.bLeftTrigger / 255.0f;

	if(z > TRIGGER_DEAD)
	{
		return z;
	}
	else
	{
		return 0;
	}
}

//=============================================================================
//右トリガー検出
//引数：接続されたコントローラーの番号
//戻値：トリガーの押され具合
//=============================================================================
float Input::getRightTrigger(int num)
{
	//接続されていなければ0を返す
	if(!connected[num - 1])
	{
		return 0;
	}
	//0〜255
	float z = (float)controllerState[num - 1].Gamepad.bRightTrigger / 255.0f;

	if(z > TRIGGER_DEAD)
	{
		return z;
	}
	else
	{
		return 0;
	}
}

//=============================================================================
//振動
//=============================================================================
void Input::vibration(int num, int leftPow, int rightPow)
{
	//振動用構造体
	XINPUT_VIBRATION vib;
	vib.wLeftMotorSpeed = leftPow;	//0〜65535
	vib.wRightMotorSpeed = rightPow;	//0〜65535

	XInputSetState(num, &vib);
}
